{
	"nodes":[
		{"id":"37f811cecb7c7c34","x":1559,"y":-3860,"width":3160,"height":1020,"color":"2","type":"group","label":"Constraints"},
		{"type":"text","text":"# Velocity Update (Kernel)\n\n* For each [[Body]] in the [[Body]] field:\n\t* $\\vec{v} \\leftarrow \\frac{x_{prev} - x}{h}$\n\t* $\\Delta \\hat{q} \\leftarrow \\hat{q}\\hat{q}^{-1}_{prev}$\n\t* $\\vec{\\omega} \\leftarrow 2\\frac{\\left[\\hat{q}_x, \\hat{q}_y, \\hat{q}_z\\right]}{h}$\n\t* $\\vec{\\omega} \\leftarrow \\Delta \\hat{q} \\ge 0 ? \\vec{\\omega} : -\\vec{\\omega}$\n\nThis is implemented as a method in the [[Body]] struct:\n```python\nself.velocity = (self.position - self.prev_position) / h\n\ndelta_orientation = quaternion.hamilton_product(self.orientation,\n\nquaternion.inverse(self.prev_orientation))\n\nangular_velocity = 2.0 * ti.Vector([ delta_orientation[1], delta_orientation[2], delta_orientation[3]])/ h\n\nif delta_orientation[0] >= 0.0:\n\n  self.angular_velocity = - angular_velocity\n\nelse:\n\n  self.angular_velocity = angular_velocity\n```\n","id":"7215b7728deb2a4f","x":4725,"y":-734,"width":1085,"height":634,"color":"4"},
		{"type":"text","text":"# Contacts Position  (Kernel)","id":"b09b2b42bb9739de","x":5267,"y":-2152,"width":614,"height":492,"color":"2"},
		{"type":"text","text":"# Contacts Velocity  (Kernel)","id":"44c78d0c2df60876","x":314,"y":-770,"width":614,"height":492,"color":"2"},
		{"type":"text","text":"# Update visual bodies\n\n","id":"459e2940b8ff8112","x":-320,"y":-3280,"width":440,"height":96,"color":"1"},
		{"type":"text","text":"Sub steps reached?\n\n`Sum one sub step`","id":"ddf88b911e0f2f44","x":-420,"y":-1976,"width":400,"height":140},
		{"type":"text","text":"# Broad Phase Collision Detection (Kernel)\n\nIn this step we iterate over the `potential collision field`, for each potential collision, we take the two bodies and its respective colliders, from these colliders we calculate the corresponding [[AABB]] and sum a safety factor of  $k \\Delta t v_{body}$ where $k\\ge 1$. As mentioned previously the colliders [[AABB]] are represented using a 2x3 Matrix  the first row representing the minimum point of the [[AABB]] and the second row the maximum point.\n\n$$\nAABB = \n\\begin{bmatrix}\nx_{min}, y_{min}, z_{min} \\\\ \nx_{max}, y_{max}, z_{max} \\\\ \n\\end{bmatrix}\n$$\n$$\nAABB_{safety} = \\begin{bmatrix}\nx_{min}, y_{min}, z_{min} \\\\ \nx_{max}, y_{max}, z_{max} \\\\ \n\\end{bmatrix} + \\frac{1}{2}k \\Delta t\n\\begin{bmatrix}\n-v_{x},-v_{y}, -v_{z} \\\\ \nv_{x}, v_{y}, v_{z} \\\\ \n\\end{bmatrix}\n$$\nWe almacenate all the results of the broad phase collision detection algorithm into a vector which we will use in the narrow phase collision detection later.","id":"49c8b6c7423bdcf6","x":-1680,"y":-2752,"width":960,"height":502,"color":"5"},
		{"type":"text","text":"# Collect Potential Collision Pairs (Python Function)\n\nIn this preparation step we create a field (vector/tensor) with all the possible collision pairs. \n\nFor example: If we have 3 objects A B C with the following collision mask.\n\n| |A| B|C|\n|-|-|-|-|\n|A|~|x|x|\n|B|x|~| |\n|C|x| |~|\n`A can collide with B an C; and B and C cannot collide with each other`\n\nWe must create a field that contains all the possible collisions to check.\n\n```\npotential_collision_field = [(A:B), (A:C)]\n```\n\nThis field has references to the [[bodies]] that collide, this references are in the form of indexes to the bodies field.","id":"ac1a3769a5cccbde","x":-3200,"y":-2752,"width":760,"height":565,"color":"5"},
		{"type":"text","text":"# Narrow Phase Collision Detection (Kernel)\n\n* For this step we iterate over the vector of `aabb_colisions` which has the same length as the field of collisions and check the collisions, if the [[AABB]] is `true` we apply the corresponding algorithm for the Narrow phase collision detection.\n\n* We currently support the following collisions:\n\t* [[Sphere v Sphere]]\n\t* [[Box v Box]]\n\t* [[Sphere v Box]]\n\t* [[Sphere  v Plane]]\n\t* [[Box v Plane]]\n\n* The result of this step is an update to the [[Collision Response]] field, with all the collision information to \n\n* **Note** : We think it may be possible to integrate Height field collisions but, it has to go trough a separate step/kernel, this is due to the limitations of the Taichi lang // programming on GPU. \n* **Note** : We also intend to implement the capsule as another collision shape","id":"28c660a90c63f0d5","x":4160,"y":-2250,"width":800,"height":500,"color":"5"},
		{"type":"text","text":"# Position Update (Kernel)\n\n* For each [[Body]] in the [[Body]] field:\n\t* We  perform a Cartesian position update: \n\t\t* $\\vec{x}_{prev} \\leftarrow \\vec{x}$\n\t\t* $\\vec{v} \\leftarrow \\vec{v} + h \\frac{\\vec{f}_{\\text{ext}}}{m}$\n\t\t* $\\vec{x} \\leftarrow \\vec{x} + \\vec{v} h$\n\t* And the angular position update:\n\t\t* $\\hat{q}_{prev} \\leftarrow \\hat{q}$\n\t\t* $\\vec{\\omega} \\leftarrow \\vec{\\omega}+ h\\textbf{I}^{-1} (\\tau_{\\text{ext}} - (\\vec{\\omega} \\times (\\textbf{I} \\vec{\\omega})))$\n\t\t* $\\textbf{q} \\leftarrow \\textbf{q} + h \\frac{1}{2} \\left[0, \\omega_x, \\omega_y, \\omega_z\\right] \\textbf{q}$  (See note)\n\t\t* $\\hat{q}\\leftarrow \\frac{\\textbf{q}}{|\\textbf{q}|}$ \n* This is implemented as a `method` of the [[Body]] struct.\n```python\n\t# Cartesian Update (If you are working with particles this is enough)\n\tself.position_prev = self.position\n\tself.velocity      = self.velocity + h * self.f_ext/self.mass\n\tself.position      = self.position + self.velocity * h\n\t# Angular Update\n\tself.orientation_prev  = self.orientation\n\tself.angular_velocity  = self.angular_velocity * h * self.inv_dyn_intertia @ (self.t_ext  - tm.cross(self.angular_velocity,  (self.dyn_intertia @ self.angular_velocity)) )\n\tself.orientation       = quaternion.rotate_by_axis_and_magnitude(self.orientation, axis = self.angular_velocity, magnitude = h)\n```\n**Note** : This formula is an approximation for rotations, also note that in the paper published by Mr. Muller and his peers, the position of the 0 in the vector is changed, this depends on the convetion on where the quaternion scalar quantity is located, it is also important to notethat the operation between  $\\left[0, \\omega_x, \\omega_y, \\omega_z\\right]$ and $q$ is the **hamilton product**.\n**Note** : Note about the inertia","id":"2d67c58160495fc0","x":320,"y":-2398,"width":1680,"height":687,"color":"4"},
		{"id":"c4b25215c0a3af53","x":2520,"y":-2398,"width":1060,"height":710,"type":"text","text":""},
		{"type":"text","text":"# Wrist Joint (Implementation Pendind)\n\n## Step : Driving the wrist joints\n* TODO\n\n## Step 2 : Angle Limits\n\n* Set the angle limit function parameters to:\n\t* $\\hat{n} = \\frac{\\hat{a}_1 + \\hat{a}_2}{|\\hat{a}_1 + \\hat{a}_2|}$\n\t* $\\hat{n_1} = |\\hat{b}_1 - \\hat{n} (\\hat{b}_1 \\cdot \\hat{n} ) |$\n\t* $\\hat{n_2} =|\\hat{b}_2 - \\hat{n} (\\hat{b}_2 \\cdot \\hat{n})|$\n* **Note**: Remember that for the hinge joints $\\hat{a}_1 = \\hat{a}_2$ \n* Apply the general angle limit formula.\\\n* If the angle limit is passed the following angular correction is applied:\n* $\\Delta \\vec{q}_{\\text{limit}} = \\hat{b_1}\\times \\hat{b_2}$\n\n### Step 3 : Attachment Point\n* Another correction that is also important to apply is the attachment point constraint, this is: A positional constraint that forces the two bodies joined by the hinge to stay attached in the hinge position.\n* This constraint is not directly mentioned in the paper, but I guess is important to make the notation of it.\n* $\\Delta \\vec{x} = \\vec{r_2} - \\vec{r_1}$\n","id":"479e804047a1e4e5","x":2359,"y":-3840,"width":740,"height":760,"color":"2"},
		{"type":"text","text":"# Hinge Joint\n\n## Step 1: Aligning Axes\n* For a hinge joint we must maintain the $\\hat{a}$ axes aligned.\n\t* $\\Delta \\vec{q}_{\\text{hinge}} = \\hat{a}_1 \\times \\hat{a}_2$\n## Step 2  (Optional) : Driving the hinge joint\n * To drive the joint to an specific angle $\\theta$ apply:\n\t * $\\hat{b}_{\\text{target}} = \\hat{b} \\cos{(\\theta)} + (\\hat{a} \\times \\hat{b} ) \\sin{(\\theta)} + \\hat{a} (\\hat{a} \\cdot \\hat{b} ) (1 - \\cos{(\\theta)})$ \n\t * $\\Delta \\vec{q}_{\\text{target}} =\\hat{b}_{\\text{target}} \\times \\hat{b}_{2}$\n* **Note**: To apply a target speed $\\omega$ instead of a target angle $\\theta$, set the target angle $\\theta$ to:\n\t* $\\theta \\leftarrow \\theta + h \\omega$\n## Step 3 : Angle Limits (Optional)\n\n* Set the angle limit function parameters to:\n\t* $\\hat{n} = \\hat{a}_1$\n\t* $\\hat{n_1} = \\hat{b}_1$\n\t* $\\hat{n_2} = \\hat{b}_2$\n* **Note**: Remember that for the hinge joints $\\hat{a}_1 = \\hat{a}_2$ \n* Apply the general angle limit formula.\n* If the angle limit is passed the following angular correction is applied:\n* $\\Delta \\vec{q}_{\\text{limit}} = \\hat{b_1}\\times \\hat{b_2}$\n\n### Step 4 : Attachment Point\n* Another correction that is also important to apply is the attachment point constraint, this is: A positional constraint that forces the two bodies joined by the hinge to stay attached in the hinge position.\n* This constraint is not directly mentioned in the paper, but I guess is important to make the notation of it.\n* $\\Delta \\vec{x} = \\vec{r_2} - \\vec{r_1}$","id":"a681653c11182730","x":1579,"y":-3840,"width":740,"height":980,"color":"2"},
		{"type":"text","text":"# Prismatic Joints\n\n* In general a prismatic joint restricts the rotation on all axes. (There are some exceptions)\n* As a previous step we must calculate the positional offset $\\Delta \\vec{r}$:\n\t* $\\Delta \\vec{r} = \\vec{r}_2 - \\vec{r}_1$\n## Step 1: Offset  \n * This correction should be applied if ($|\\Delta \\vec{r}| > d_{max}$)\n $$\n \\Delta \\vec{x} = \\frac{\\Delta \\vec{r}}{|\\Delta \\vec{r}|} (|\\Delta \\vec{r}| - d_{max})\n$$\n\n* If we want to drive the joint to a target with a force $f$ we set the compliance to:\n\t* $\\alpha = \\frac{(|\\Delta \\vec{r}| - d_{\\text{target}})}{f}$\n## Step 2: Orientation\n* We assume that the two bodies are have its mutual orientations aligned.\n* $\\vec q = \\hat{q}_1 \\hat{q}_2^{-1}$\n* $\\Delta\\vec{q} = 2\\left[\\vec{q_x}, \\vec{q_y}, \\vec{q_z} \\right]$\n\n","id":"93c297460789eb1c","x":3139,"y":-3840,"width":760,"height":680,"color":"2"},
		{"type":"text","text":"# Rigid Joints\n* We calculate $\\Delta \\vec{r}$\n\t*  $\\Delta \\vec{r} = \\vec{r}_2 - \\vec{r}_1$\n\n## Step 1: Position  \n $$\n \\Delta \\vec{x} = \\Delta \\vec{r} \n$$\n\n## Step 2: Orientation\n* We assume that the two bodies are have its mutual orientations aligned.\n* $\\vec q = \\hat{q}_1 \\hat{q}_2^{-1}$\n* $\\Delta\\vec{q} = 2\\left[\\vec{q_x}, \\vec{q_y}, \\vec{q_z} \\right]$","id":"c8d3f0bee5195848","x":3939,"y":-3840,"width":760,"height":525,"color":"2"},
		{"type":"text","text":"# Positional Constraint (Function)\n\nFor the positional constraint, we take as input:\n\n* The two [[Body]] that interact in the constraint.\n* The [[Positional Constraint]] information \n\n\n\n## Step 1:\n* Calculate the generalized inverse mass for each of the bodies that interact:\n$$\nw \\leftarrow \\frac{1}{m} + (\\vec{r}  \\times \\hat{n})^{T} \\textbf{I}^{-1} (\\vec{r} \\times \\hat{n})\n$$\n* $m$ : Mass of the body\n* $\\textbf{I}$ : **Dynamic** inertia tensor. (Is the inertia tensor of the body rotated by its rotation matrix)\n* $\\hat{n}$ : Direction of the constraint\n* $\\vec{r}$ : Vector relative to the center of mass of the body that indicates where the constraint is located.\nThis computation is implemented as a method of the [[Body]]  struct that receives $\\vec{r}$ and  $\\hat{n}$ as arguments.\n## Step 2:\n\n* Computes the Lagrange multiplier of the constraint:\n$$\n\\Delta \\lambda \\leftarrow \\frac{-c - \\tilde{\\alpha} \\lambda}{w_1 + w_2 + \\tilde{\\alpha}}\n$$\n* $\\tilde \\alpha$ being:\n$$\n\\tilde \\alpha = \\frac{\\alpha}{h^2}\n$$\n## Step 3:\n* Update the Lagrange multiplier and calculate the impulse/correction ($\\vec{p}$):\n$$\n\\lambda \\leftarrow \\lambda + \\Delta\\lambda\n$$\n$$\n\\vec{p} \\leftarrow \\Delta\\lambda\\hat{n}\n$$\n## Step 4\n\n* Apply the positional correction $\\vec{p}$ to both bodies (This is implemented as a method for the body struct)\n\n$$\n\\vec{x} \\leftarrow \\vec{x} \\pm \\frac{\\vec{p}}{m}\n$$\n$$\n\\textbf{q} \\leftarrow \\hat{q}  \\pm \\frac{1}{2} \\left[0, \\textbf{I}^{-1}(\\vec{r}\\times \\vec{p})\\right] \\hat{q}  \n$$\n$$\n\\hat{q} \\leftarrow \\frac{\\textbf{q}}{|\\textbf{q}|}\n$$\n\nNote that if for one of the bodies the impulse is applied positively, for the other body it will be negative.\n","id":"3baece09e293b814","x":1579,"y":-5520,"width":761,"height":1540,"color":"3"},
		{"type":"text","text":"# Angular Constraint (Function)\n\nFor the angular constraint we need:\n* The two [[Body]](s) that interact\n* The [[Angular Constraint]] information.\n\n## Step 1\n\n* Calculate the generalized inverse mass (For angular constraints).","id":"d662874a39c57eda","x":2500,"y":-5520,"width":761,"height":640,"color":"3"},
		{"id":"3d6f7a66ffcd5ac9","x":3480,"y":-5480,"width":920,"height":680,"color":"3","type":"text","text":"# Angle Limits\n\n## Inputs:\n* $\\left[\\theta_{\\text{min}}, \\theta_{\\text{max}} \\right]$  : Interval\n* $\\hat{n}$ : Common rotation angle\n* $(\\hat{n}_1, \\hat{n}_2)$ .\n\n1. Get the angle:\n\t* $\\phi \\leftarrow \\arctan{\\frac{(\\hat{n}_1 \\times \\hat{n}_2)\\cdot \\hat{n}}{(\\hat{n}_1 \\cdot \\hat{n}_2)}}$     \n2. Now check if the angle is on the interval:\n\t* If the angle is not in the interval $\\left[\\theta_{\\text{min}}, \\theta_{\\text{max}} \\right]$  :\n\t\t* $\\phi \\leftarrow \\text{clamp}\\left(\\phi, \\theta_{\\text{min}},\\theta_{\\text{max}} \\right)$ \n\t\t* $\\vec{q}_{\\text{rot}} = \\text{rot}(\\vec{n}, \\phi)$\n\t\t* $\\hat{n}_1 \\leftarrow \\text{rot}(\\vec{q}_{\\text{rot}}, \\hat{n}_1)$\n\t\t* $\\Delta \\vec{q}_{\\text{limit}} = \\hat{n_1}\\times \\hat{n_2}$\n\t* If the angle is in the interval return `False`\n"}
	],
	"edges":[
		{"id":"fae493f15d54382a","fromNode":"49c8b6c7423bdcf6","fromSide":"bottom","toNode":"ddf88b911e0f2f44","toSide":"left"},
		{"id":"8bfd7ba319de7bc0","fromNode":"b09b2b42bb9739de","fromSide":"right","toNode":"7215b7728deb2a4f","toSide":"right"},
		{"id":"fdaba0525151c073","fromNode":"7215b7728deb2a4f","fromSide":"left","toNode":"44c78d0c2df60876","toSide":"right"},
		{"id":"bcd513f41296cb98","fromNode":"44c78d0c2df60876","fromSide":"left","toNode":"ddf88b911e0f2f44","toSide":"bottom"},
		{"id":"a6859285cd9cb986","fromNode":"28c660a90c63f0d5","fromSide":"right","toNode":"b09b2b42bb9739de","toSide":"left"},
		{"id":"b4e68e5541d0f805","fromNode":"ddf88b911e0f2f44","fromSide":"right","toNode":"2d67c58160495fc0","toSide":"left","label":"No"},
		{"id":"d7332c86d089de4f","fromNode":"ddf88b911e0f2f44","fromSide":"top","toNode":"459e2940b8ff8112","toSide":"right","label":"Yes"},
		{"id":"0debd9048b21545a","fromNode":"459e2940b8ff8112","fromSide":"left","toNode":"49c8b6c7423bdcf6","toSide":"top"},
		{"id":"1ef47cf210c7f366","fromNode":"2d67c58160495fc0","fromSide":"right","toNode":"c4b25215c0a3af53","toSide":"left"},
		{"id":"25b89f158c4dbdb9","fromNode":"c4b25215c0a3af53","fromSide":"right","toNode":"28c660a90c63f0d5","toSide":"left"}
	]
}