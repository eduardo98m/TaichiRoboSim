{
	"nodes":[
		{"type":"text","text":"# Rotational Joint Constraints (Kernel)\n","id":"67b719b805c08fc2","x":2200,"y":-2152,"width":614,"height":492,"color":"2"},
		{"type":"text","text":"# Cartesian Joint Constraints (Kernel)","id":"d6cc91f192e7af1f","x":3080,"y":-2152,"width":614,"height":492,"color":"2"},
		{"type":"text","text":"# Narrow Phase Collision Detection (Kernel)\n\n* For this step we iterate over the vector of `aabb_colisions` which has the same length as the field of collisions and check the collisions, if the [[AABB]] is `true` we apply the corresponding algorithm for the Narrow phase collision detection.\n\n* We currently support the following collisions:\n\t* [[Sphere v Sphere]]\n\t* [[Box v Box]]\n\t* [[Sphere v Box]]\n\t* [[Sphere  v Plane]]\n\t* [[Box v Plane]]\n\n* The result of this step is an update to the [[Collision Response]] field, with all the collision information to \n\n* **Note** : We think it may be possible to integrate Height field collisions but, it has to go trough a separate step/kernel, this is due to the limitations of the Taichi lang // programming on GPU. \n* **Note** : We also intend to implement the capsule as another collision shape","id":"28c660a90c63f0d5","x":3962,"y":-2160,"width":800,"height":500,"color":"5"},
		{"type":"text","text":"# Velocity Update (Kernel)\n\n* For each [[Body]] in the [[Body]] field:\n\t* $\\vec{v} \\leftarrow \\frac{x_{prev} - x}{h}$\n\t* $\\Delta \\hat{q} \\leftarrow \\hat{q}\\hat{q}^{-1}_{prev}$\n\t* $\\vec{\\omega} \\leftarrow 2\\frac{\\left[\\hat{q}_x, \\hat{q}_y, \\hat{q}_z\\right]}{h}$\n\t* $\\vec{\\omega} \\leftarrow \\Delta \\hat{q} \\ge 0 ? \\vec{\\omega} : -\\vec{\\omega}$\n\nThis is implemented as a method in the [[Body]] struct:\n```python\nself.velocity = (self.position - self.prev_position) / h\n\ndelta_orientation = quaternion.hamilton_product(self.orientation,\n\nquaternion.inverse(self.prev_orientation))\n\nangular_velocity = 2.0 * ti.Vector([ delta_orientation[1], delta_orientation[2], delta_orientation[3]])/ h\n\nif delta_orientation[0] >= 0.0:\n\n  self.angular_velocity = - angular_velocity\n\nelse:\n\n  self.angular_velocity = angular_velocity\n```\n","id":"7215b7728deb2a4f","x":4725,"y":-734,"width":1085,"height":634,"color":"4"},
		{"type":"text","text":"# Position Update (Kernel)\n\n* For each [[Body]] in the [[Body]] field:\n\t* We  perform a Cartesian position update: \n\t\t* $\\vec{x}_{prev} \\leftarrow \\vec{x}$\n\t\t* $\\vec{v} \\leftarrow \\vec{v} + h \\frac{\\vec{f}_{\\text{ext}}}{m}$\n\t\t* $\\vec{x} \\leftarrow \\vec{x} + \\vec{v} h$\n\t* And the angular position update:\n\t\t* $\\hat{q}_{prev} \\leftarrow \\hat{q}$\n\t\t* $\\vec{\\omega} \\leftarrow \\vec{\\omega}+ h\\textbf{I}^{-1} (\\tau_{\\text{ext}} - (\\vec{\\omega} \\times (\\textbf{I} \\vec{\\omega})))$\n\t\t* $\\textbf{q} \\leftarrow \\textbf{q} + h \\frac{1}{2} \\left[0, \\omega_x, \\omega_y, \\omega_z\\right] \\textbf{q}$  (See note)\n\t\t* $\\hat{q}\\leftarrow \\frac{\\textbf{q}}{|\\textbf{q}|}$ \n* This is implemented as a `method` of the [[Body]] struct.\n```python\n\t# Cartesian Update (If you are working with particles this is enough)\n\tself.position_prev = self.position\n\tself.velocity      = self.velocity + h * self.f_ext/self.mass\n\tself.position      = self.position + self.velocity * h\n\t# Angular Update\n\tself.orientation_prev  = self.orientation\n\tself.angular_velocity  = self.angular_velocity * h * self.inv_dyn_intertia @ (self.t_ext  - tm.cross(self.angular_velocity,  (self.dyn_intertia @ self.angular_velocity)) )\n\tself.orientation       = quaternion.rotate_by_axis_and_magnitude(self.orientation, axis = self.angular_velocity, magnitude = h)\n```\n**Note** : This formula is an approximation for rotations, also note that in the paper published by Mr. Muller and his peers, the position of the 0 in the vector is changed, this depends on the convetion on where the quaternion scalar quantity is located, it is also important to notethat the operation between  $\\left[0, \\omega_x, \\omega_y, \\omega_z\\right]$ and $q$ is the **hamilton product**.\n**Note** : Note about the inertia","id":"2d67c58160495fc0","x":314,"y":-2250,"width":1680,"height":687,"color":"4"},
		{"type":"text","text":"# Contacts Position  (Kernel)","id":"b09b2b42bb9739de","x":5267,"y":-2152,"width":614,"height":492,"color":"2"},
		{"type":"text","text":"# Contacts Velocity  (Kernel)","id":"44c78d0c2df60876","x":314,"y":-770,"width":614,"height":492,"color":"2"},
		{"type":"text","text":"# Update visual bodies\n\n","id":"459e2940b8ff8112","x":-320,"y":-3280,"width":440,"height":96,"color":"1"},
		{"type":"text","text":"Sub steps reached?\n\n`Sum one sub step`","id":"ddf88b911e0f2f44","x":-420,"y":-1976,"width":400,"height":140},
		{"type":"text","text":"# Broad Phase Collision Detection (Kernel)\n\nIn this step we iterate over the `potential collision field`, for each potential collision, we take the two bodies and its respective colliders, from these colliders we calculate the corresponding [[AABB]] and sum a safety factor of  $k \\Delta t v_{body}$ where $k\\ge 1$. As mentioned previously the colliders [[AABB]] are represented using a 2x3 Matrix  the first row representing the minimum point of the [[AABB]] and the second row the maximum point.\n\n$$\nAABB = \n\\begin{bmatrix}\nx_{min}, y_{min}, z_{min} \\\\ \nx_{max}, y_{max}, z_{max} \\\\ \n\\end{bmatrix}\n$$\n$$\nAABB_{safety} = \\begin{bmatrix}\nx_{min}, y_{min}, z_{min} \\\\ \nx_{max}, y_{max}, z_{max} \\\\ \n\\end{bmatrix} + \\frac{1}{2}k \\Delta t\n\\begin{bmatrix}\n-v_{x},-v_{y}, -v_{z} \\\\ \nv_{x}, v_{y}, v_{z} \\\\ \n\\end{bmatrix}\n$$\nWe almacenate all the results of the broad phase collision detection algorithm into a vector which we will use in the narrow phase collision detection later.","id":"49c8b6c7423bdcf6","x":-1680,"y":-2752,"width":960,"height":502,"color":"5"},
		{"type":"text","text":"# Collect Potential Collision Pairs (Python Function)\n\nIn this preparation step we create a field (vector/tensor) with all the possible collision pairs. \n\nFor example: If we have 3 objects A B C with the following collision mask.\n\n| |A| B|C|\n|-|-|-|-|\n|A|~|x|x|\n|B|x|~| |\n|C|x| |~|\n`A can collide with B an C; and B and C cannot collide with each other`\n\nWe must create a field that contains all the possible collisions to check.\n\n```\npotential_collision_field = [(A:B), (A:C)]\n```\n\nThis field has references to the [[bodies]] that collide, this references are in the form of indexes to the bodies field.","id":"ac1a3769a5cccbde","x":-3200,"y":-2752,"width":760,"height":565,"color":"5"},
		{"type":"text","text":"# Positional Constraint (Function)","id":"3baece09e293b814","x":2319,"y":-3232,"width":761,"height":555,"color":"3"},
		{"type":"text","text":"# Angular Constraint (Function)","id":"d662874a39c57eda","x":4382,"y":-3280,"width":761,"height":555,"color":"3"}
	],
	"edges":[
		{"id":"fae493f15d54382a","fromNode":"49c8b6c7423bdcf6","fromSide":"bottom","toNode":"ddf88b911e0f2f44","toSide":"left"},
		{"id":"8bfd7ba319de7bc0","fromNode":"b09b2b42bb9739de","fromSide":"right","toNode":"7215b7728deb2a4f","toSide":"right"},
		{"id":"fdaba0525151c073","fromNode":"7215b7728deb2a4f","fromSide":"left","toNode":"44c78d0c2df60876","toSide":"right"},
		{"id":"bcd513f41296cb98","fromNode":"44c78d0c2df60876","fromSide":"left","toNode":"ddf88b911e0f2f44","toSide":"bottom"},
		{"id":"51b61e70224d8b70","fromNode":"2d67c58160495fc0","fromSide":"right","toNode":"67b719b805c08fc2","toSide":"left"},
		{"id":"e6d20082550db5fb","fromNode":"67b719b805c08fc2","fromSide":"right","toNode":"d6cc91f192e7af1f","toSide":"left"},
		{"id":"1444add347f3b705","fromNode":"d6cc91f192e7af1f","fromSide":"right","toNode":"28c660a90c63f0d5","toSide":"left"},
		{"id":"a6859285cd9cb986","fromNode":"28c660a90c63f0d5","fromSide":"right","toNode":"b09b2b42bb9739de","toSide":"left"},
		{"id":"b4e68e5541d0f805","fromNode":"ddf88b911e0f2f44","fromSide":"right","toNode":"2d67c58160495fc0","toSide":"left","label":"No"},
		{"id":"d7332c86d089de4f","fromNode":"ddf88b911e0f2f44","fromSide":"top","toNode":"459e2940b8ff8112","toSide":"right","label":"Yes"},
		{"id":"0debd9048b21545a","fromNode":"459e2940b8ff8112","fromSide":"left","toNode":"49c8b6c7423bdcf6","toSide":"top"}
	]
}